[Config FastSMR]
network = abstract.VirtualNet
# network parameters
VirtualNet.npc_num = 5

# global observer
## global simulation parameters
## maximum distance could be, for example, half of the Earth circumference: 20000000m
**.globalParameters.max_distance = 20000000m
**.globalParameters.fix_latency = 1000ms
## network latency generation mode. 
## 0: Simulation of real-world latency generated by 1) light transmission limit, 2) communication congestion, and 3) jitter 
## 1: Latency generation with minimal singl-trip latency (Dmin) and jitter, i.e., Dmin + jitter
**.globalParameters.latency_gen_mode = 0
## Chord overlay parameters
**.globalParameters.chord_init_size = 10
**.globalParameters.address_space_size = 20
**.globalParameters.successor_list_size = 2
**.globalParameters.chord_replica_size = 2
## game map parameters 
**.globalParameters.map_length = 4
**.globalParameters.map_width = 4
**.globalParameters.map_height = 4
**.globalParameters.map_bottom = 0
**.globalParameters.map_file = "server_nodes.json"

## global statistics parameters
## the time after which the sent events will not be included in drop rate calculation
**.globalStatistics.cool_down = 10s

# network configurator
**.underlayConfigurator.meshType = "abstract.Mesh"
**.underlayConfigurator.meshName = "Mesh"
**.underlayConfigurator.nodeType = "hosts.Node"
**.underlayConfigurator.nodeName = "node"
**.underlayConfigurator.clientType = "hosts.Client"
**.underlayConfigurator.clientName = "client"
**.underlayConfigurator.login_loop = 1000ms
**.underlayConfigurator.remove_wait = 5000ms
**.underlayConfigurator.chord_type = "hosts.Chord"
**.underlayConfigurator.chord_name = "chord"
**.underlayConfigurator.npcType = "hosts.NPC"
**.underlayConfigurator.npcName = "NPC"

# system-level parameters
#**.delay = 50ms + truncnormal(50ms, ${stddev = 50, 100, 150, 200, 250}ms)

# chord control protocol parameters
## chord maintenance cycle: 1000ms
**.chord[*].ctrl.maintain_cycle = 1000000ms
## average size of object files to download: 5898262B = 4.5MB
**.chord[*].ctrl.object_size = 5898262B

# client parameters
# the cycle for initiating connection trials to the replicas of a logical computer
**.client[*].ctrl.initJoinTime = 3000ms
# the cycle for initiating connection trials to the replicas of a logical computer
**.client[*].ctrl.handshakeTime = 500ms
# the cycle for user to change the "connect" flag to load a logical computer 
**.client[*].ctrl.loadCycle = 500ms
# the cycle for neighbor discovery 
**.client[*].ctrl.discoveryCycle = 1000ms
# whether the schedule of event dispatch at client will be deviated
**.client[*].ctrl.deviate = false
# client application-level parameters
**.client[*].app.step = 200ms
**.client[*].app.comm_loop = 200ms
# perception range
**.client[*].app.perception = 500

# client-mesh (i.e., NPC) parameters
**.NPC[*].ctrl.initJoinTime = 3000ms

# logical computer parameters

# host parameter
# to minimize the opsportunity of group failure, mean and stdvar should be configured to large values
**.node[*].IPInterface = "IPAddress"
**.node[*].RendezvousInterface = "RendezvousInterface"
**.node[*].HBcycle = 10000ms
**.node[*].ClientInterruption = 5000ms

# replica control parameters
**.node[*].ctrl.roundCycle = 200ms
# time to start event collection cycle
**.node[*].ctrl.cycleStart = 4000ms
# garbage collection gossip cycle
**.node[*].ctrl.GCCycle = 20000ms

# replica application layer configuratoins

# Rendezvous parameters, 10s
**.rendezvous.ctrl.cycle = 10000ms
**.rendezvous.ctrl.starttime = 5000ms
## for replica number calculation for a new replication
**.rendezvous.replicaNumPolicyModule = "replication"
**.rendezvous.replication.threshold = 3
### for BasicReplicaNumPolicy 
**.rendezvous.replication.max_replica = 5

# clock configurations
**.clock.err_mean = 74ms
**.clock.err_std = 175ms

# UDP packet transmission configuration
## packet loss rate
**.pktLossRate = 0.00
## 2/3 of the light speed
**.Copt = 200000000mps
## 10 mega bits per second
**.BW = 1.04858e6bps
## Ethernet packet size 1518 Bytpes = 12144 bits
**.MTU = 12144b
**.jitter_mu = 1
**.jitter_sigma = 0.5
# minimal end-to-end delay
**.Dmin = 50ms
**.jitter = 50ms

# churn generator configuration
**.churnGeneratorModule = "churnGenerator"
## for WeibullChurnGenerator, unit of minutes
### fraction of stable nodes, from cloud or datacenter servers
**.churnGenerator.stable_fraction = 0.2
### stable node lifetime is modelled by an exponential distribution, mean = 2.5 hours
**.churnGenerator.stable_mean = 9000000ms
### unit of minutes
**.churnGenerator.sessionLenShape = 0.38
**.churnGenerator.sessionLenScale = 42.4
#**.churnGenerator.sessionLenMin = 10min
**.churnGenerator.sessionLenMin = 10s
## for ManualChurnGenerator, unit of  minutes
**.churnGenerator.sessionLength = 30min
**.churnGenerator.scan_cycle = 1000ms
## for UniformChurnGenerator
**.churnGenerator.life_span_min = 10s
**.churnGenerator.life_span_max = 1000s

# For coordinator module
**.coordinator.locXMax = 850
**.coordinator.locYMax = 800
**.coordinator.locXMin = 200
**.coordinator.locYMin = 150
## the boundary of logical computer
**.coordinator.LCXMax = 1050
**.coordinator.LCYMax = 800
**.coordinator.LCXMin = 900
**.coordinator.LCYMin = 150
## radius of percept, same as the value of **.client[*].app.perception
**.coordinator.percept_radius=500

# result recording
**.result-recording-modes = all
**.statistic-recording = true
**.scalar-recording = true

[General]
#scheduler-class = "cSequentialScheduler"
# if need real-time telnet support, use cRealTimeScheduler
scheduler-class = "cRealTimeScheduler"
# microsecond
simtime-resolution = ms
# Minimal time unit of simulation duration can only be second
sim-time-limit = 1020s
warmup-period = 10s
num-rngs = 1
rng-class = cMersenneTwister
seed-0-mt = 200
repeat = 1
#debug-on-errors = false
#cmdenv-event-banners = true
# for performance consideration, the signal check control can be changed to false
check-signals = false
record-eventlog = false